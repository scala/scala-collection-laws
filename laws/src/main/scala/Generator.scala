package laws

/** Generates code for a particular element/collection combination.
  *
  * To understand what the various methods do, inspect where they are used inside the code generation.
  */
trait Generator[A, B, CC] {
  def instanceExplorer(): Exploratory[Instance[A, CC]]
  def opsExplorer(): Exploratory[Ops[A, B]]
  def autoTags: Set[Flag]
  def ccType: String
  def eltType: String
  def eltCC: String = eltType
  def safeElt: String = eltType.collect{
    case ',' => '_'
    case c if c.isLetterOrDigit => c
  }.mkString // TODO--remove `mkString` when String has `collect` again!
  def altType: String
  def heritage: String
  def generatorName: String
  def pkgName: String
  def pkgFull: String
  def colType: String = f"$pkgFull.$ccType[$eltCC]"
  def instTypes: String = f"$eltType, $colType"
  def opsTypes: String = f"$eltType, $altType"

  /** The name of the generated test class */
  def className: String = f"Test_${pkgName}_${ccType}_${safeElt}"

  /** Generates the code */
  def code: String = {
    val instance = instanceExplorer.completeIterator.take(1).toList.head
    val quotedMethods = instance.methods.methods.
      toList.sorted.
      map{ s => "\"" + (if (s contains '\\') s.replaceAllLiterally("\\", "\\\\") else s) + "\"" }
    val appropriate = Laws.all.
      filter(law => law.checker passes instance.methods).
      filter(law => law.tags compatible (autoTags ++ instance.flags)).
      sortBy(_.lineNumber);
    (
      Array(
        f"// Autogenerated test for collection $ccType with element type $eltType",
        f"",
        f"package laws",
        f"",
        f"class $className(numb: Numbers, oper: Ops[$opsTypes], inst: Instance[$instTypes], lln: Int)",
        f"extends $heritage[$colType, $className](numb, oper, inst, lln) {",
        f"  import Test.Once.Conversions._",
        if (instance.flags contains Flag.SEQ) {
         "  import Test.EqualInOrder"
        }
        else {
         "  import Test.EqualInCount"
        },
        f"  import Test.SubsetInCount",
        f"  import Test.Logic",
        f"  import Test.SameCompilerType",
        f"",
        f"",
        f"  def renumber(numb: Numbers) = ",
        f"    new $className(numb, ops, instance, lawLine)",
        f"",
        f"  def reinstance(inst: Instance[$instTypes]) = ",
        f"    new $className(num, ops, inst, lawLine)",
        f"",
        f"  def reoperate(oper: Ops[$opsTypes]) = ",
        f"    new $className(num, oper, instance, lawLine)",
        f"",
        f"  def relaw(lln: Int) = new $className(num, ops, instance, lln)",
        f"",
        f"  /***** Individual laws begin here *****/",
        f""
      ) ++
      appropriate.map{ law =>
        f"  def runLaw${law.lineNumber}: Boolean = {\n" +
        law.cleanCode.split("\n").map("    " + _).mkString("", "\n", "\n") +
        f"  }\n"
      } ++
      Array(
        f"  /****** Individual laws end here ******/",
        f"",
        f"  val lawTable: Map[Int, () => Boolean] = Map("
      ) ++
      appropriate.map(_.lineNumber).zipWithIndex.map{ case (n, i) =>
        f"    $n -> (runLaw$n _)${if (i+1 < appropriate.length)"," else ""}"
      } ++
      Array(
        f"  )",
        f"",
        f"  def runLaw(n: Int): Option[Boolean] = lawTable.get(n).map(_())",
        f"}",
        f"",
        f"",
        f"object $className extends Test.Companion {",
      f"""  def name = "$className" """,
        f"",
        f"  val lawNumbers = ${appropriate.map(_.lineNumber).mkString("Set[Int](", ", ", ")")}",
        f"",
        f"  val obeys = lawNumbers.map(n => n -> Laws.byLineNumber(n)).toMap",
        f"",
        f"  val methods = Set(${quotedMethods.mkString(", ")})",
        f"",
        f"  val factory: (Int, Instance[$instTypes], Ops[$opsTypes], Numbers) => $className =",
        f"    (l, i, o, n) => new $className(n, o, i, l)",
        f"",
        f"  val instanceExpy = () => $generatorName.instanceExplorer",
        f"",
        f"  val opsExpy = () => $generatorName.opsExplorer",
        f"",
        f"  def runnerOf(lln: Int): Runner[$eltType, $altType, $colType, $className] =",
        f"    new Runner(lln, instanceExpy, opsExpy, factory)",
        f"",
        f"  def run(lln: Int): Either[Outcome, Long] = runnerOf(lln).run",
        f"}",
        f""
      )
    ).mkString("\n")
  }
}

/** Generates tests for collections using `Int` elements */
abstract class IntGenerator[CC] extends Generator[Int, Long, CC] {
  val opsExplorer = Ops.IntExplorer
  val heritage = "IntTest"
  val eltType = "Int"
  val altType = "Long"
  val autoTags = Set(Flag.INT)
}

/** Generates tests for collections using `String` elements */
abstract class StrGenerator[CC] extends Generator[String, Option[String], CC] {
  val opsExplorer = Ops.StrExplorer
  val heritage = "StrTest"
  val eltType = "String"
  val altType = "Option[String]"
  val autoTags = Set(Flag.STR)
  override def className: String = f"Test_${pkgName}_${ccType}_Str"
}

/** Generates tests for collections (maps, specifically) using `(Long, String)` elements */
abstract class LongStrGenerator[CC] extends Generator[(Long, String), (String, Long), CC] {
  val opsExplorer = Ops.LongStrExplorer
  val heritage = "LongStrTest"
  val eltType = "(Long, String)"
  val altType = "(String, Long)"
  val autoTags = Set.empty[Flag]
}

/** Generates tests for collections (maps, specifically) using `(String, Long)` elements */
abstract class StrLongGenerator[CC] extends Generator[(String, Long), (Long, String), CC] {
  val opsExplorer = Ops.StrLongExplorer
  val heritage = "StrLongTest"
  val eltType = "(String, Long)"
  val altType = "(Long, String)"
  val autoTags = Set.empty[Flag]
}

/** Generates all classes testing collections that take `Int` element types.
  *
  * Many commonalities with `AllStrGenerators`, but it's a such a pain to make everything generic that it's not worth abstracting.
  */
object AllIntGenerators {
  val io = InstantiatorsOfInt

  /** An actual generator */
  class Gen[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[Int, CC], ct: String = "")(implicit name: sourcecode.Name)
  extends IntGenerator[CC] {
    def generatorName = f"AllIntGenerators.${p.nickname}.${name.value}"
    def pkgName = p.nickname
    def pkgFull = p.fullyQualified
    override def colType = if (ct.isEmpty) super.colType else ct
    val instanceExplorer = io.map(iexp(p).tupled)
    def ccType = name.value.toString.capitalize
  }

  private val everyoneBuffer = Array.newBuilder[Gen[_, _]]

  /** Registers a particular generator to write its output to a file */
  def register[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[Int, CC], ct: String = "")(implicit name: sourcecode.Name): Gen[P, CC] = {
    val ans = new Gen(p)(iexp, ct)(name)
    everyoneBuffer += ans
    ans
  }

  /** Generators for all immutable collections.
    *
    * This is a fairly tedious listing of everything in the corresponding instantiator.
    *
    * For now, this is kept separate to make it easier to temporarily leave out problematic collections.
    * (You'll get a warning if you leave one out, though.)
    */
  object Imm {
    val arraySeq = register(io.Imm)(_.arraySeq())
    val hashSet = register(io.Imm)(_.hashSet())
    val indexedSeq = register(io.Imm)(_.indexedSeq())
    val iterable = register(io.Imm)(_.iterable())
    val lazyList = register(io.Imm)(_.lazyList())
    val linearSeq = register(io.Imm)(_.linearSeq())
    val list = register(io.Imm)(_.list())
    val queue = register(io.Imm)(_.queue())
    val seq = register(io.Imm)(_.seq())
    val set = register(io.Imm)(_.set())
    val sortedSet = register(io.Imm)(_.sortedSet())
    val stream = register(io.Imm)(_.stream())
    val traversable = register(io.Imm)(_.traversable())
    val treeSet = register(io.Imm)(_.treeSet())
    val vector = register(io.Imm)(_.vector())
  }

  /** Generators for all mutable collections.
    *
    * This is a fairly tedious listing of everything in the corresponding instantiator.
    *
    * For now, this is kept separate to make it easier to temporarily leave out problematic collections.
    * (You'll get a warning if you leave one out, though.)
    */
  object Mut {
    val array = register(io.Mut)(_.array(), "Array[Int]")
    val arrayBuffer = register(io.Mut)(_.arrayBuffer())
    val arrayDeque = register(io.Mut)(_.arrayDeque())
    val arraySeq = register(io.Mut)(_.arraySeq())
    val arrayStack = register(io.Mut)(_.arrayStack())
    val buffer = register(io.Mut)(_.buffer())
    val hashSet = register(io.Mut)(_.hashSet())
    val indexedSeq = register(io.Mut)(_.indexedSeq())
    val iterable = register(io.Mut)(_.iterable())
    val linkedHashSet = register(io.Mut)(_.linkedHashSet())
    val listBuffer = register(io.Mut)(_.listBuffer())
    val priorityQueue = register(io.Mut)(_.priorityQueue())
    val queue = register(io.Mut)(_.queue())
    val seq = register(io.Mut)(_.seq())
    val stack = register(io.Mut)(_.stack())
    val treeSet = register(io.Mut)(_.treeSet())
    val wrappedArray = register(io.Mut)(_.wrappedArray())
  }

  /** Generator for accumulators and anything else used in conversions */
  object Conv {
    // TODO--get Ops-like abstractions to work; then this can be used
    // val accumulator = register(io.Conv)(_.accumulator())
    val anyAccumulator = register(io.Conv)(_.anyAccumulator())
  }

  /** Generator for iterators and views. */
  object Root {
    val iterator       = register(io.Root)(_.iterator())
    val view           = register(io.Root)(_.view())

    // These don't work because they require a different collection type for arguments
    // val indexedSeqView = register(io.Root)(_.indexedSeqView())
    // val seqView        = register(io.Root)(_.seqView())
  }

  /** Generator for immutable collections that take only ints (which belong here, since we're dealing with ints). */
  object ImmInt {
    val bitSet = register(io.ImmInt)(_.bitSet(), "collection.immutable.BitSet")
    //val range = register(io.ImmInt)(_.range(), "collection.immutable.Range")
  }

  /** Generator for mutable collections that take only ints (which belong here, since we're dealing with ints). */
  object MutInt {
    val bitSet = register(io.MutInt)(_.bitSet(), "collection.mutable.BitSet")
  }

  /** Generator for Int-specialized accumulators */
  object ConvInt {
    val intAccumulator = register(io.ConvInt)(_.intAccumulator(), "scala.jdk.IntAccumulator")
  }

  /** This line is needed to actually perform the registration of all generators! */
  val force = Imm :: Mut :: Conv :: Root :: ImmInt :: MutInt :: ConvInt :: Nil

  /** All registered generators */
  lazy val all = everyoneBuffer.result

  /** Writes all the classes to the indicated directory.  Returns a map indicating which ones
    * actually changed.  (If the generated code is identical to the file, the file is not re-written.)
    */
  def write(targetDir: java.io.File): Map[String, Boolean] =
    all.map(g => g.className -> FileIO(new java.io.File(targetDir, g.className + ".scala"), g.code)).toMap
}

/** Generates all classes that test collections taking `String` element types.
  *
  * Many commonalities with `AllStrGenerators`, but it's a such a pain to make everything generic that it's not worth abstracting.
  */
object AllStrGenerators {
  val io = InstantiatorsOfStr

  /** An actual generator */
  class Gen[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[String, CC], ct: String = "")(implicit name: sourcecode.Name)
  extends StrGenerator[CC] {
    def generatorName = f"AllStrGenerators.${p.nickname}.${name.value}"
    def pkgName = p.nickname
    def pkgFull = p.fullyQualified
    override def colType = if (ct.isEmpty) super.colType else ct
    val instanceExplorer = io.map(iexp(p).tupled)
    def ccType = name.value.toString.capitalize
  }

  private val everyoneBuffer = Array.newBuilder[Gen[_, _]]

  /** Registers a particular generator to write its output to a file */
  def register[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[String, CC], ct: String = "")(implicit name: sourcecode.Name): Gen[P, CC] = {
    val ans = new Gen(p)(iexp, ct)(name)
    everyoneBuffer += ans
    ans
  }

  /** Generators for all immutable collections.
    *
    * This is a fairly tedious listing of everything in the corresponding instantiator.
    *
    * For now, this is kept separate to make it easier to temporarily leave out problematic collections.
    * (You'll get a warning if you leave one out, though.)
    */
  object Imm {
    val arraySeq = register(io.Imm)(_.arraySeq())
    val hashSet = register(io.Imm)(_.hashSet())
    val indexedSeq = register(io.Imm)(_.indexedSeq())
    val iterable = register(io.Imm)(_.iterable())
    val lazyList = register(io.Imm)(_.lazyList())
    val linearSeq = register(io.Imm)(_.linearSeq())
    val list = register(io.Imm)(_.list())
    val queue = register(io.Imm)(_.queue())
    val seq = register(io.Imm)(_.seq())
    val set = register(io.Imm)(_.set())
    val sortedSet = register(io.Imm)(_.sortedSet())
    val stream = register(io.Imm)(_.stream())
    val traversable = register(io.Imm)(_.traversable())
    val treeSet = register(io.Imm)(_.treeSet())
    val vector = register(io.Imm)(_.vector())
  }

  /** Generators for all mutable collections.
    *
    * This is a fairly tedious listing of everything in the corresponding instantiator.
    *
    * For now, this is kept separate to make it easier to temporarily leave out problematic collections.
    * (You'll get a warning if you leave one out, though.)
    */
  object Mut {
    val array = register(io.Mut)(_.array(), "Array[String]")
    val arrayBuffer = register(io.Mut)(_.arrayBuffer())
    val arrayDeque = register(io.Mut)(_.arrayDeque())
    val arraySeq = register(io.Mut)(_.arraySeq())
    val arrayStack = register(io.Mut)(_.arrayStack())
    val buffer = register(io.Mut)(_.buffer())
    val hashSet = register(io.Mut)(_.hashSet())
    val indexedSeq = register(io.Mut)(_.indexedSeq())
    val iterable = register(io.Mut)(_.iterable())
    val linkedHashSet = register(io.Mut)(_.linkedHashSet())
    val listBuffer = register(io.Mut)(_.listBuffer())
    val priorityQueue = register(io.Mut)(_.priorityQueue())
    val queue = register(io.Mut)(_.queue())
    val seq = register(io.Mut)(_.seq())
    val stack = register(io.Mut)(_.stack())
    val treeSet = register(io.Mut)(_.treeSet())
    val wrappedArray = register(io.Mut)(_.wrappedArray())
  }

  /** Generator for accumulators and anything else used in conversions */
  object Conv {
    // TODO--get Ops-like abstractions to work; then this can be used
    // val accumulator = register(io.Conv)(_.accumulator())
    val anyAccumulator = register(io.Conv)(_.anyAccumulator())
  }

  /** Generator for iterators. */
  object Root {
    val iterator       = register(io.Root)(_.iterator())
    val view           = register(io.Root)(_.view())

    // These don't work because they require a different collection type for arguments
    // val indexedSeqView = register(io.Root)(_.indexedSeqView())
    // val seqView        = register(io.Root)(_.seqView())
  }

  /** This line is needed to actually perform the registration of all generators! */
  val force = Imm :: Mut :: Conv :: Root :: Nil

  /** All registered generators */
  lazy val all = everyoneBuffer.result

  /** Writes all the classes to the indicated directory.  Returns a map indicating which ones
    * actually changed.  (If the generated code is identical to the file, the file is not re-written.)
    */
  def write(targetDir: java.io.File): Map[String, Boolean] =
    all.map(g => g.className -> FileIO(new java.io.File(targetDir, g.className + ".scala"), g.code)).toMap
}

/** Generates all classes that test collections (maps) with `(Long, String)` element types.
  *
  * Many commonalities with other generators, but it's a such a pain to make everything generic that it's not worth abstracting.
  */
object AllLongStrGenerators {
  val io = InstantiatorsOfLongStr

  class Gen[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[(Long, String), CC], ct: String = "")(implicit name: sourcecode.Name)
  extends LongStrGenerator[CC] {
    def generatorName = f"AllLongStrGenerators.${p.nickname}.${name.value}"
    def pkgName = p.nickname
    def pkgFull = p.fullyQualified
    override def colType = if (ct.isEmpty) super.colType else ct
    val instanceExplorer = io.map(iexp(p).tupled)
    def ccType = name.value.toString.capitalize
    override lazy val eltCC = eltType.dropWhile(_ == '(').reverse.dropWhile(_ == ')').reverse
  }

  private val everyoneBuffer = Array.newBuilder[Gen[_, _]]

  def register[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[(Long, String), CC], ct: String = "")(implicit name: sourcecode.Name): Gen[P, CC] = {
    val ans = new Gen(p)(iexp, ct)(name)
    everyoneBuffer += ans
    ans
  }

  object ImmKV {
    val hashMap    = register(io.ImmKV)(_.hashMap())
    val listMap    = register(io.ImmKV)(_.listMap())
    val sortedMap  = register(io.ImmKV)(_.sortedMap())
    val treeMap    = register(io.ImmKV)(_.treeMap())
    val treeSeqMap = register(io.ImmKV)(_.treeSeqMap())
    val vectorMap  = register(io.ImmKV)(_.vectorMap())
  }

  object MutKV {
    val collisionProofHashMap =
                        register(io.MutKV)(_.collisionProofHashMap())
    val hashMap       = register(io.MutKV)(_.hashMap())
    val listMap       = register(io.MutKV)(_.listMap())
    val linkedHashMap = register(io.MutKV)(_.linkedHashMap())
    val openHashMap   = register(io.MutKV)(_.openHashMap())
    val sortedMap     = register(io.MutKV)(_.sortedMap())
    val treeMap       = register(io.MutKV)(_.treeMap())
    val weakHashMap   = register(io.MutKV)(_.weakHashMap())
  }

  object MutLongV {
    val longMap       = register(io.MutLongV)(_.longMap(), "collection.mutable.LongMap[String]")
  }

  /** This line is needed to actually perform the registration of all generators! */
  val force = ImmKV :: MutKV :: MutLongV :: Nil

  lazy val all = everyoneBuffer.result

  def write(targetDir: java.io.File): Map[String, Boolean] =
    all.map(g => g.className -> FileIO(new java.io.File(targetDir, g.className + ".scala"), g.code)).toMap
}

/** Generates all classes that test collections (maps) with `(String, Long)`
  * Many commonalities with other generators, but it's a such a pain to make everything generic that it's not worth abstracting.
  */
object AllStrLongGenerators {
  val io = InstantiatorsOfStrLong

  class Gen[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[(String, Long), CC], ct: String = "")(implicit name: sourcecode.Name)
  extends StrLongGenerator[CC] {
    def generatorName = f"AllStrLongGenerators.${p.nickname}.${name.value}"
    def pkgName = p.nickname
    def pkgFull = p.fullyQualified
    override def colType = if (ct.isEmpty) super.colType else ct
    val instanceExplorer = io.map(iexp(p).tupled)
    def ccType = name.value.toString.capitalize
    override lazy val eltCC = eltType.dropWhile(_ == '(').reverse.dropWhile(_ == ')').reverse
  }

  private val everyoneBuffer = Array.newBuilder[Gen[_, _]]

  def register[P <: Instance.PackagePath, CC](p: P)(iexp: P => Instance.FromArray[(String, Long), CC], ct: String = "")(implicit name: sourcecode.Name): Gen[P, CC] = {
    val ans = new Gen(p)(iexp, ct)(name)
    everyoneBuffer += ans
    ans
  }

  object ImmKV {
    val hashMap    = register(io.ImmKV)(_.hashMap())
    val listMap    = register(io.ImmKV)(_.listMap())
    val sortedMap  = register(io.ImmKV)(_.sortedMap())
    val treeMap    = register(io.ImmKV)(_.treeMap())
    val treeSeqMap = register(io.ImmKV)(_.treeSeqMap())
    val vectorMap  = register(io.ImmKV)(_.vectorMap())
  }

  object MutKV {
    val collisionProofHashMap =
                        register(io.MutKV)(_.collisionProofHashMap())
    val hashMap       = register(io.MutKV)(_.hashMap())
    val listMap       = register(io.MutKV)(_.listMap())
    val linkedHashMap = register(io.MutKV)(_.linkedHashMap())
    val openHashMap   = register(io.MutKV)(_.openHashMap())
    val sortedMap     = register(io.MutKV)(_.sortedMap())
    val treeMap       = register(io.MutKV)(_.treeMap())
    val weakHashMap   = register(io.MutKV)(_.weakHashMap())
  }

  object MutKrefV {
    val anyRefMap     = register(io.MutKrefV)(_.anyRefMap())
  }

  /** This line is needed to actually perform the registration of all generators! */
  val force = ImmKV :: MutKV :: MutKrefV :: Nil

  lazy val all = everyoneBuffer.result

  def write(targetDir: java.io.File): Map[String, Boolean] =
    all.map(g => g.className -> FileIO(new java.io.File(targetDir, g.className + ".scala"), g.code)).toMap
}

/** The global generator that runs all particular generators of tests
  * and generates supervisory test files that run all the tests.
  */
object GenerateAll {
  /** Creates a master test that runs all the tests.
    *
    * The output is suitable for exploring with `Reports`.
    */
  def writeUniversalTest(targetDir: java.io.File, tests: List[String]): (String, Boolean) = {
    val name = "Test_Everything"
    val target = new java.io.File(targetDir, name + ".scala")
    val lines = (
      Array(
        f"package laws",
        f"",
        f"object $name extends AllRunner {",
        f"  val runners: Array[() => (String, () => Test.Tested)] = Array(",
        tests.map{ t => 
      f"""    () => "$t" -> (() => $t.runAll())"""
        }.mkString(",\n"),
        f"  )",
        f"}"
      )
    )
    (name, FileIO(target, lines.mkString("\n")))
  }

  /** Creates a master jUnit test that marks all the tests for running via jUnit.
    *
    * Also hooks into the `@BeforeClass` and `@AfterClass` machinery to
    * give summary reports.
    */
  def writeJUnitAdaptor(targetDir: java.io.File, tests: List[String]): (String, Boolean) = {
    val name = "Test_Everything_With_JUnit"
    val targetPath = new java.io.File(targetDir, "src/test/scala")
    if (!targetPath.exists) targetPath.mkdirs
    val target = new java.io.File(targetPath, name + ".scala")
    val lines = (
      Array(
        f"package laws",
        f"",
        f"class $name {"
      ) ++
      tests.zipWithIndex.flatMap{ case (t, i) => Array(
        f"  @org.junit.Test",
        f"  def run_$t: Unit = {",
        f"    val (n, test) = Test_Everything.runners($i).apply()",
        f"    $name.result.put(n, test.apply())",
        f"  }"
      )} ++
      Array(
        f"}",
        f"",
        f"object $name {",
        f"  val result = new java.util.concurrent.ConcurrentHashMap[String, Test.Tested]",
        f"  @org.junit.BeforeClass def setup: Unit =  { result.clear() }",
        f"  @org.junit.AfterClass  def report: Unit = { Report.junitReport(result) }",
        f"}",
        f""
      )
    )
    (name, FileIO(target, lines.mkString("\n")))
  }

  /** Write all tests and test-supervisors to the given directory.
    *
    * Returns a map that indicates whether or not each test file
    * was actually updated, and a `Vector` that names all the
    * collections that were somehow left out of testing.
    */
  def write(targetDir: java.io.File): (Map[String, Boolean], Vector[String]) = {
    val tests =    
      AllIntGenerators.write(targetDir) ++
      AllStrGenerators.write(targetDir) ++
      AllLongStrGenerators.write(targetDir) ++
      AllStrLongGenerators.write(targetDir)
    val everySource: Vector[Instance.Deployed] =
      InstantiatorsOfInt.all ++
      InstantiatorsOfStr.all ++
      InstantiatorsOfLongStr.all ++
      InstantiatorsOfStrLong.all
    val testNames = tests.map(_._1).toList.sorted
    val universal = writeUniversalTest(targetDir, testNames)
    val junit  = writeJUnitAdaptor(targetDir, testNames)
    val missingSources = everySource.filter(_.accesses == 0).map(_.path)
    (tests + universal + junit, missingSources.sorted)
  }

  /** Writes all the tests into a named directory (if the argument list is length one),
    * or into the default directory (if the argument list is empty).  It is an error
    * to pass multiple arguments.
    *
    * Returns `true` if all collections have tests, `false` if any were missed (i.e.
    * were registered in `Instantiators` but weren't generated), and throws an
    * exception if anything unexpected happens.
    */
  def run(args: Array[String]): Boolean = {
    val path = args match {
      case Array() => "tests"
      case Array(f) => f
      case _ => throw new IllegalArgumentException(f"Zero or one paths for output only (found ${args.length})")
    }

    val (upd, miss) = write(new java.io.File(path))

    println(f"Generated code for ${upd.size} collection/element combinations")
    println(f"  ${upd.count(_._2)} updated since last run")

    if (miss.nonEmpty) {
      println(f"Generators unimplemented for ${miss.size} collection/element sets:")
      miss.foreach(m => println("  " + m))
      false
    }
    else true
  }

  /** Writes all the tests into the default directory (which is `tests`). */
  def default(): Unit = { 
    run(Array.empty)
  }

  /** Writes all the tests into the named (if there is one argument) or default
    * directory (if there are no arguments).
    *
    * Exits with an error code if any collections are completely untested.
    */
  def main(args: Array[String]): Unit = {
    if (!run(args)) sys.exit(1)
  }
}
